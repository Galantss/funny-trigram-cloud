<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>YouTube Live → Funny Trigram Word Cloud</title>
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <style>
    :root{
      --bg:#0b0d10; --panel:#12161c; --muted:#657087; --text:#e8edf7; --acc:#4f8cff; --ok:#2ecc71; --warn:#f1c40f; --bad:#ff6b6b;
      --bar:#263241; --barfill:#4f8cff;
    }
    *{box-sizing:border-box}
    body{margin:0;background:var(--bg);color:var(--text);font:16px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,"Helvetica Neue",Arial}
    header{padding:22px 18px;border-bottom:1px solid #1c232d;background:linear-gradient(180deg,#0e1217,transparent)}
    h1{margin:0;font-size:20px;font-weight:700;letter-spacing:.2px}
    main{max-width:1100px;margin:0 auto;padding:18px}
    .card{background:var(--panel);border:1px solid #202734;border-radius:14px;padding:16px;margin-bottom:16px}
    label{display:block;margin:.6rem 0 .25rem;color:#b9c2d0;font-weight:600}
    input[type="text"], textarea{width:100%;background:#0e1116;border:1px solid #1e2631;color:var(--text);padding:10px 12px;border-radius:10px;outline:none}
    textarea{min-height:110px;resize:vertical}
    .row{display:grid;gap:12px}
    @media(min-width:850px){ .row{grid-template-columns:2fr 1fr} }
    .btn{
      display:inline-flex;align-items:center;gap:.6rem;padding:10px 14px;border-radius:10px;border:1px solid #2a3546;
      background:linear-gradient(180deg,#1a2230,#141a24);color:var(--text);cursor:pointer;font-weight:700
    }
    .btn:disabled{opacity:.5;cursor:not-allowed}
    .btn.secondary{background:#0e1116}
    .hint{color:var(--muted);font-size:13px;margin-top:6px}
    .progress{margin-top:10px;background:var(--bar);border-radius:10px;overflow:hidden;height:10px;border:1px solid #223046}
    .bar{height:100%;width:0%;background:var(--barfill);transition:width .25s ease}
    .steps{margin-top:10px;font-size:13px}
    .step{display:flex;align-items:center;gap:8px;margin:6px 0}
    .dot{width:10px;height:10px;border-radius:50%;}
    .dot.todo{background:#344355}
    .dot.doing{background:var(--warn)}
    .dot.done{background:var(--ok)}
    .spinner{
      --s:16px; width:var(--s); height:var(--s); border-radius:50%; border:2px solid #2a3a52; border-top-color:var(--acc);
      animation:spin .9s linear infinite; display:inline-block
    }
    @keyframes spin{to{transform:rotate(360deg)}}
    canvas{width:100%;max-width:1100px;height:600px;background:#0b0f15;border:1px dashed #253142;border-radius:12px}
    .grid{display:grid;grid-template-columns:1fr;gap:16px}
    @media(min-width:980px){ .grid{grid-template-columns:2fr 1fr}}
    table{border-collapse:collapse;width:100%;font-size:14px}
    td,th{border-bottom:1px solid #223046;padding:8px 6px;text-align:left}
    th{color:#c7d2e3;font-weight:700}
    .pill{display:inline-block;padding:2px 8px;border-radius:999px;background:#1a2330;border:1px solid #2a3444;color:#c2cee0;font-size:12px}
    .footer{color:#95a2b9;font-size:12px;margin-top:8px}
    .shadow{box-shadow:0 10px 30px rgba(0,0,0,.25)}
    .sep{height:1px;background:#212a38;margin:12px -16px}
    .right{display:flex;gap:8px;align-items:center;justify-content:flex-end;flex-wrap:wrap}
    .sr-only{position:absolute !important; left:-10000px; top:auto; width:1px; height:1px; overflow:hidden;}
  </style>
</head>
<body>
  <header>
    <h1>YouTube Live → Funny Trigram Word Cloud</h1>
  </header>

  <main>
    <section class="card shadow">
      <div class="row">
        <div>
          <label for="ytUrl">YouTube URL (ended live or regular video)</label>
          <input id="ytUrl" type="text" placeholder="https://www.youtube.com/watch?v=VIDEO_ID or https://youtu.be/VIDEO_ID">
          <div class="hint">We’ll try to fetch public captions. If blocked or missing, paste/upload below.</div>
        </div>
        <div class="right">
          <button id="goBtn" class="btn"><span class="spinner" id="goSpin" style="display:none"></span> Fetch & Build Cloud</button>
          <button id="clearBtn" class="btn secondary">Clear</button>
        </div>
      </div>

      <div id="progressWrap" style="display:none">
        <div class="progress" aria-live="polite" aria-label="Fetch progress">
          <div id="bar" class="bar"></div>
        </div>
        <div class="steps" id="steps">
          <!-- Steps injected -->
        </div>
      </div>
    </section>

    <section class="card">
      <div class="row">
        <div>
          <label for="paste">Or paste a transcript</label>
          <textarea id="paste" placeholder="Paste raw transcript or captions (we’ll ignore timestamps)"></textarea>
        </div>
        <div>
          <label for="file">Or upload captions (.vtt or .srt)</label>
          <input id="file" type="file" accept=".vtt,.srt,text/vtt,text/plain,application/x-subrip">
          <div class="hint">We’ll parse and merge lines automatically.</div>
        </div>
      </div>
    </section>

    <section class="grid">
      <section class="card">
        <div class="right" style="margin-bottom:10px">
          <button id="downloadBtn" class="btn secondary" disabled>Download PNG</button>
          <span class="pill" id="tokenInfo" title="Words considered after cleaning">Tokens: 0</span>
          <span class="pill" id="triInfo" title="Unique trigrams">Trigrams: 0</span>
        </div>
        <canvas id="cloud" width="1100" height="600" aria-label="Word cloud canvas"></canvas>
        <div class="footer">Tip: If the cloud looks sparse, try uploading/pasting the full transcript or a different language track.</div>
      </section>

      <section class="card">
        <h3 style="margin:0 0 8px 0">Top funny trigrams</h3>
        <div class="hint">Size ∝ <code>score = freq × (laughter + emoji + punctuation + spice)</code></div>
        <div class="sep"></div>
        <div style="max-height:560px;overflow:auto">
          <table id="table">
            <thead><tr><th>#</th><th>Trigram</th><th>Score</th><th>Freq</th></tr></thead>
            <tbody></tbody>
          </table>
        </div>
      </section>
    </section>
  </main>

  <script>
    // ---------- Small helpers ----------
    const $ = sel => document.querySelector(sel);
    const goBtn = $("#goBtn"), clearBtn = $("#clearBtn");
    const goSpin = $("#goSpin");
    const bar = $("#bar"), stepsBox = $("#steps"), progressWrap = $("#progressWrap");
    const pasteEl = $("#paste"), fileEl = $("#file"), urlEl = $("#ytUrl");
    const canvas = $("#cloud"), ctx = canvas.getContext("2d");
    const tblBody = $("#table tbody");
    const tokenInfo = $("#tokenInfo"), triInfo = $("#triInfo");
    const dlBtn = $("#downloadBtn");

    const STEPS = [
      "Parse video URL",
      "Discover caption tracks",
      "Pick best track",
      "Fetch captions",
      "Parse captions",
      "Extract trigrams",
      "Score funniness",
      "Render cloud"
    ];

    let cancelToken = {cancel:false};

    function resetProgress(){
      stepsBox.innerHTML = "";
      progressWrap.style.display = "none";
      bar.style.width = "0%";
      cancelToken = {cancel:false};
    }

    function startProgress(){
      progressWrap.style.display = "block";
      stepsBox.innerHTML = "";
      STEPS.forEach((s,i)=>{
        const row = document.createElement("div");
        row.className = "step";
        row.id = "step-"+i;
        row.innerHTML = `<span class="dot todo"></span><span>${s}</span>`;
        stepsBox.appendChild(row);
      });
      setBar(3);
    }

    function markStep(i, state){
      const row = $("#step-"+i);
      if(!row) return;
      const dot = row.querySelector(".dot");
      dot.classList.remove("todo","doing","done");
      dot.classList.add(state);
      if(state==="doing") row.appendChild(Object.assign(document.createElement("span"),{className:"spinner",style:"margin-left:4px"}));
      if(state==="done"){
        const sp = row.querySelector(".spinner"); if(sp) sp.remove();
      }
    }

    function setBar(pct){
      bar.style.width = Math.max(0, Math.min(100, pct))+"%";
    }

    function fail(message, stepIndex){
      if(typeof stepIndex==="number") markStep(stepIndex,"doing");
      console.error(message);
      const row = document.createElement("div");
      row.className = "step";
      row.innerHTML = `<span class="dot" style="background:var(--bad)"></span><span>${message}</span>`;
      stepsBox.appendChild(row);
      setBar(100);
      goBtn.disabled = false;
      goSpin.style.display = "none";
    }

    // ---------- Core flow ----------
    async function run(){
      goBtn.disabled = true; goSpin.style.display = "inline-block";
      dlBtn.disabled = true;
      clearCanvas();
      tblBody.innerHTML = "";
      tokenInfo.textContent = "Tokens: 0"; triInfo.textContent = "Trigrams: 0";
      startProgress();

      try{
        // STEP 0: Parse video URL
        markStep(0,"doing"); setBar(8);
        const userUrl = urlEl.value.trim();
        let videoId = extractVideoId(userUrl);
        markStep(0,"done");

        // If no URL, but user provided paste or file, just use that route.
        let transcript = "";
        if(!videoId && !pasteEl.value && !fileEl.files?.length){
          fail("Provide a YouTube URL, paste a transcript, or upload a .vtt/.srt.",0);
          return;
        }

        // If file provided, parse it directly.
        if(fileEl.files?.length){
          markStep(3,"doing"); setBar(20);
          transcript = await readFileAsText(fileEl.files[0]);
          markStep(3,"done");
          markStep(4,"doing");
          transcript = captionsToPlainText(transcript);
          markStep(4,"done");
        } else if(pasteEl.value){
          markStep(4,"doing"); setBar(22);
          transcript = captionsToPlainText(pasteEl.value);
          markStep(4,"done");
        } else {
          // Fetch from YouTube captions
          // STEP 1: discover tracks
          markStep(1,"doing"); setBar(26);
          const tracks = await discoverTracks(videoId);
          markStep(1,"done");

          if(!tracks.length){
            fail("No public caption tracks found. Try pasting or uploading captions.",1);
            return;
          }

          // STEP 2: pick best
          markStep(2,"doing"); setBar(32);
          const best = pickBestTrack(tracks);
          markStep(2,"done");

          // STEP 3: fetch captions
          markStep(3,"doing"); setBar(45);
          const vtt = await fetchCaptions(videoId, best);
          markStep(3,"done");

          // STEP 4: parse captions
          markStep(4,"doing"); setBar(58);
          transcript = captionsToPlainText(vtt);
          markStep(4,"done");
        }

        if(cancelToken.cancel) return;

        // STEP 5: extract trigrams
        markStep(5,"doing"); setBar(70);
        const tokens = tokenize(transcript);
        tokenInfo.textContent = "Tokens: " + tokens.length.toLocaleString();
        const {trigrams, freqMap} = makeTrigrams(tokens);
        triInfo.textContent = "Trigrams: " + trigrams.length.toLocaleString();
        markStep(5,"done");

        // STEP 6: score
        markStep(6,"doing"); setBar(82);
        const scored = scoreTrigrams(freqMap);
        markStep(6,"done");

        // STEP 7: render
        markStep(7,"doing"); setBar(90);
        await renderCloud(scored.slice(0,150));
        fillTable(scored.slice(0,200));
        markStep(7,"done");
        setBar(100);
        dlBtn.disabled = false;

      }catch(err){
        console.error(err);
        fail("Unexpected error: " + (err?.message || err), undefined);
      } finally {
        goBtn.disabled = false; goSpin.style.display = "none";
      }
    }

    // ---------- YouTube captions ----------
    function extractVideoId(url){
      if(!url) return "";
      try{
        // handle plain IDs
        if(/^[A-Za-z0-9_-]{11}$/.test(url)) return url;

        const u = new URL(url);
        if(u.hostname.includes("youtu.be")){
          // https://youtu.be/VIDEO_ID
          const id = u.pathname.split("/").filter(Boolean)[0] || "";
          return id;
        }
        if(u.searchParams.get("v")) return u.searchParams.get("v");
        // shorts or other paths
        const parts = u.pathname.split("/").filter(Boolean);
        if(parts[0]==="shorts" && parts[1]) return parts[1];
        return "";
      } catch { return ""; }
    }

    async function discoverTracks(videoId){
      // YouTube provides a "list" XML of caption tracks
      // Common endpoints (CORS-friendly):
      //   https://video.google.com/timedtext?type=list&v=VIDEO_ID
      const listUrl = `https://video.google.com/timedtext?type=list&v=${encodeURIComponent(videoId)}`;
      const res = await fetchWithProgress(listUrl, 10, 22, "Discover caption tracks");
      if(!res.ok) return [];
      const xml = await res.text();
      const doc = new DOMParser().parseFromString(xml,"text/xml");
      const nodes = [...doc.getElementsByTagName("track")];
      return nodes.map(n=>({
        lang: n.getAttribute("lang_code"),
        name: n.getAttribute("name") || "",
        kind: n.getAttribute("kind") || ""
      }));
    }

    function pickBestTrack(tracks){
      // Prefer en auto > en > first
      let best = tracks.find(t=>/^en(-|$)/.test(t.lang) && /auto/i.test(t.name || ""));
      if(!best) best = tracks.find(t=>/^en(-|$)/.test(t.lang));
      if(!best) best = tracks[0];
      return best;
    }

    async function fetchCaptions(videoId, track){
      // Try VTT first
      const base = `https://video.google.com/timedtext?v=${encodeURIComponent(videoId)}`;
      const vttUrl = `${base}&lang=${encodeURIComponent(track.lang)}${track.name?`&name=${encodeURIComponent(track.name)}`:""}&fmt=vtt`;
      let res = await fetchWithProgress(vttUrl, 46, 57, "Fetch VTT");
      if(res.ok){
        return await res.text();
      }
      // Fallback to XML and convert to VTT-ish
      const xmlUrl = `${base}&lang=${encodeURIComponent(track.lang)}${track.name?`&name=${encodeURIComponent(track.name)}`:""}`;
      res = await fetchWithProgress(xmlUrl, 46, 57, "Fetch XML captions");
      if(!res.ok) throw new Error("Could not fetch captions");
      const xml = await res.text();
      return xmlToPseudoVtt(xml);
    }

    // Wrap fetch to tick the progress bar gently during network waits
    async function fetchWithProgress(url, fromPct, toPct, label){
      const totalSteps = 6; // fake mini-steps to show motion
      let step = 0;
      const interval = setInterval(()=>{
        step++;
        const pct = fromPct + (Math.min(step,totalSteps)/totalSteps)*(toPct - fromPct);
        setBar(pct);
      }, 250);
      try{
        const res = await fetch(url, {mode:"cors", credentials:"omit", cache:"no-store"});
        return res;
      } finally {
        clearInterval(interval);
      }
    }

    function xmlToPseudoVtt(xml){
      // Very basic: strip tags and join "text" nodes
      const doc = new DOMParser().parseFromString(xml,"text/xml");
      return [...doc.getElementsByTagName("text")]
        .map(n=> (n.textContent || "").replace(/\s+/g," ").trim())
        .join("\n");
    }

    function captionsToPlainText(raw){
      // remove tags
      let t = raw.replace(/<[^>]+>/g," ");
      // drop WEBVTT header
      t = t.replace(/^WEBVTT[^\n]*\n+/i,"");
      // remove timing lines like 00:00:01.000 --> 00:00:03.000
      t = t.replace(/\d+:\d{2}:\d{2}\.\d{3}\s+-->\s+\d+:\d{2}:\d{2}\.\d{3}.*/g," ");
      t = t.replace(/\d{2}:\d{2}\.\d{3}\s+-->\s+\d{2}:\d{2}\.\d{3}.*/g," ");
      // remove cue indexes (numbers alone lines)
      t = t.replace(/^\s*\d+\s*$/gm," ");
      // unescape HTML entities in XML captions
      t = t.replace(/&amp;/g,"&").replace(/&lt;/g,"<").replace(/&gt;/g,">").replace(/&quot;/g,'"').replace(/&#39;/g,"'");
      // collapse whitespace
      t = t.replace(/\s+/g," ").trim();
      return t;
    }

    function readFileAsText(file){
      return new Promise((resolve,reject)=>{
        const fr = new FileReader();
        fr.onload = ()=>resolve(String(fr.result||""));
        fr.onerror = reject;
        fr.readAsText(file);
      });
    }

    // ---------- NLP-ish ----------
    function tokenize(text){
      // Keep words, numbers, and emoji. Lowercase latin words.
      const emojiRegex = /[\p{Extended_Pictographic}]/u;
      const tokens = [];
      let cur = "";
      for(const ch of text){
        if(/[A-Za-z0-9'\-]/.test(ch) || emojiRegex.test(ch)){
          cur += ch;
        } else {
          if(cur){
            tokens.push(normalizeToken(cur));
            cur = "";
          }
        }
      }
      if(cur) tokens.push(normalizeToken(cur));
      return tokens.filter(Boolean);
    }

    function normalizeToken(tok){
      // lowercase only alphabetic segments; keep emojis as is
      if (/[\p{Extended_Pictographic}]/u.test(tok)) return tok;
      return tok.toLowerCase();
    }

    function makeTrigrams(tokens){
      const freq = new Map();
      for(let i=0;i<tokens.length-2;i++){
        const tri = `${tokens[i]} ${tokens[i+1]} ${tokens[i+2]}`;
        if(!freq.has(tri)) freq.set(tri,0);
        freq.set(tri, freq.get(tri)+1);
      }
      const trigrams = [...freq.keys()];
      return {trigrams, freqMap:freq};
    }

    function scoreTrigrams(freqMap){
      const laugh = new Set(["lol","lmao","lmfao","haha","hahaha","hah","rofl","hehe"]);
      const emojiLaugh = ["😂","🤣","😹"];
      const spicy = new Set(["damn","heck","wtf","crap","shit","ass","hell","dang","friggin","bro","dude"]);

      const rows = [];
      for(const [tri,f] of freqMap.entries()){
        let s = f;
        const t = tri.split(" ");
        const triSet = new Set(t);
        // laughter words boost
        const laughCount = t.filter(w=>laugh.has(w)).length;
        if(laughCount) s *= (1 + 0.6 * laughCount);
        // emoji boost
        const emoCount = t.filter(w=>emojiLaugh.includes(w)).length;
        if(emoCount) s *= (1 + 0.8 * emoCount);
        // punctuation-ish tokens
        if(t.some(w=>/[!?]{1,}$/.test(w))) s *= 1.15;
        // spicy/colloquial
        const spiceCount = t.filter(w=>spicy.has(w)).length;
        if(spiceCount) s *= (1 + 0.25 * spiceCount);
        // weirdness: mix of long+short juxtaposition
        if(t.some(w=>w.length>=10) && t.some(w=>w.length<=3)) s *= 1.08;

        rows.push({tri, freq:f, score: s});
      }
      rows.sort((a,b)=> b.score - a.score || b.freq - a.freq);
      return rows;
    }

    // ---------- Cloud rendering ----------
    function clearCanvas(){
      ctx.clearRect(0,0,canvas.width,canvas.height);
      ctx.fillStyle = "#0b0f15";
      ctx.fillRect(0,0,canvas.width,canvas.height);
    }

    async function renderCloud(rows){
      clearCanvas();
      const boxes = [];
      const pad = 4;
      // Compute font sizes based on score
      const scores = rows.map(r=>r.score);
      const min = Math.min(...scores), max = Math.max(...scores);
      const size = s => {
        if(!isFinite(min) || !isFinite(max) || max<=min) return 16;
        const t = (s - min) / (max - min);
        return 12 + Math.round(t * 56); // 12–68px
      };
      // place words on spiral
      for(const r of rows){
        const fs = size(r.score);
        ctx.font = `${fs}px/1.1 ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Arial`;
        const text = r.tri;
        const w = ctx.measureText(text).width + pad*2;
        const h = fs*1.2 + pad*2;

        const pos = placeOnSpiral(w,h,boxes);
        if(!pos) continue;
        boxes.push({...pos,w,h,text,fs});
        // draw
        ctx.fillStyle = "#e8edf7";
        ctx.save();
        ctx.translate(pos.x + pad, pos.y + fs + pad);
        ctx.fillText(text,0,0);
        ctx.restore();
      }
    }

    function placeOnSpiral(w,h,boxes){
      const cw = canvas.width, ch = canvas.height;
      const cx = cw/2, cy = ch/2;
      const maxR = Math.hypot(cx,cy);
      const step = 7; // px per step
      const angleStep = 0.25; // radians
      let r=0, a=0;
      for(let iter=0; iter<4000; iter++){
        const x = Math.round(cx + r*Math.cos(a) - w/2);
        const y = Math.round(cy + r*Math.sin(a) - h/2);
        const box = {x,y,w,h};
        if(x>=0 && y>=0 && x+w<=cw && y+h<=ch && !intersects(box, boxes)){
          return {x,y};
        }
        a += angleStep;
        r += step*angleStep/Math.PI; // gentle spiral
        if(r>maxR) break;
      }
      return null;
    }

    function intersects(b, arr){
      for(const o of arr){
        if(!(b.x+b.w < o.x || o.x+o.w < b.x || b.y+b.h < o.y || o.y+o.h < b.y)) return true;
      }
      return false;
    }

    function fillTable(rows){
      const frag = document.createDocumentFragment();
      rows.slice(0,200).forEach((r,i)=>{
        const tr = document.createElement("tr");
        tr.innerHTML = `<td>${i+1}</td><td>${escapeHtml(r.tri)}</td><td>${r.score.toFixed(2)}</td><td>${r.freq}</td>`;
        frag.appendChild(tr);
      });
      tblBody.innerHTML = "";
      tblBody.appendChild(frag);
    }

    function escapeHtml(s){
      return s.replace(/[&<>"']/g, m=>({ "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;" }[m]));
    }

    // ---------- Events ----------
    goBtn.addEventListener("click", ()=>run());
    clearBtn.addEventListener("click", ()=>{
      urlEl.value = ""; pasteEl.value = ""; fileEl.value = "";
      resetProgress(); clearCanvas(); tblBody.innerHTML = "";
      tokenInfo.textContent = "Tokens: 0"; triInfo.textContent = "Trigrams: 0";
      dlBtn.disabled = true;
    });
    dlBtn.addEventListener("click", ()=>{
      const link = document.createElement("a");
      link.download = "funny-trigram-cloud.png";
      link.href = canvas.toDataURL("image/png");
      link.click();
    });

    // ---------- Kick things off ----------
    resetProgress();
    clearCanvas();

  </script>
</body>
</html>
